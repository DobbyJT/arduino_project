#define ENC_COUNT_REV 330 //pulse per 1 rotation(360degree)
#define WHEEL_RADIUS 0.067

//Left Motor
#define Encoder_L_PulseA 18 // Yellow
#define Encoder_L_PulseB 19 // White
#define EN_L 9 //left velocity
#define Motor_L_pin1 2
#define Motor_L_pin2 3 //left motor 

//Right Motor
#define Encoder_R_PulseA 20 // Yellow
#define Encoder_R_PulseB 21 // White
#define Motor_R_pin1 4 
#define Motor_R_pin2 5 //right motor
#define EN_R 10 //right velocity

#define pwm_L 255

volatile int EncoderCount_L = 0; //per one rotation
float kp, kd, ki;
double integral = 0.0;
long preT = 0;
double error=0.0;
double pre_error=0.0;

void setup() {
  Serial.begin(9600);
  //left motor pinmode
  pinMode(Motor_L_pin1, OUTPUT);
  pinMode(Motor_L_pin2, OUTPUT);
  pinMode(EN_L,  OUTPUT);
  pinMode(Encoder_L_PulseA, INPUT);
  pinMode(Encoder_L_PulseB, INPUT);

  //right motor pinmode
  pinMode(Motor_R_pin1, OUTPUT);
  pinMode(Motor_R_pin2, OUTPUT);
  pinMode(EN_R,  OUTPUT);
  pinMode(Encoder_R_PulseA, INPUT_PULLUP);
  pinMode(Encoder_R_PulseB, INPUT_PULLUP);
  delay(5000); // delay 5 seconds to run

  attachInterrupt(digitalPinToInterrupt(Encoder_L_PulseA),EncoderPositionRead, RISING);

  digitalWrite(Motor_L_pin1, HIGH);
  digitalWrite(Motor_L_pin2, LOW); //확인해보기 앞 뒤 주행
  analogWrite(EN_L, pwm_L);
  PID_gain();


}

void loop() {
  long nowT = micros();
  double dt = ((double)(nowT - preT)/1.0e6);
  float velocity_L = Convert_CtoV(EncoderCount_L, dt);

  //pid
  pid(error, dt);

  //for next loop
  EncoderCount_L = 0;
  preT = nowT;
}

//반시계 방향이 정방향일 때 (Left Motor 기준)
void EncoderPositionRead() {
  if (digitalRead(Encoder_L_PulseA) == digitalRead(Encoder_L_PulseB)) {
    EncoderCount_L++;
  } 
  else {
    EncoderCount_L--;
  }
}

void PID_gain(){
  kp = 0.8;
  ki = 0.2;
  kd = 0.1;
}

double pid(double error, double dt)
{
  double proportional = error;
  integral = integral + error * dt;
  double derivative = (error - pre_error) / dt;
  pre_error = error;
  double output = (kp * proportional) + (ki * integral) + (kd * derivative);
  return output;
}

float Convert_CtoV(int count, double dt){
  float rpm = (float)(count * 60.0 / ENC_COUNT_REV /dt);
  float circumference = 2 * 3.141592 * WHEEL_RADIUS;
  float velocity = rpm / 60.0 * circumference;
  return velocity;
}
